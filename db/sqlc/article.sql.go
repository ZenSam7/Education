// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: article.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createArticle = `-- name: CreateArticle :one
INSERT INTO articles (title, text, authors)
VALUES ($1, $2, $3)
RETURNING id_article, created_at, edited_at, title, text, comments, authors, evaluation
`

type CreateArticleParams struct {
	Title   string  `json:"title"`
	Text    string  `json:"text"`
	Authors []int32 `json:"authors"`
}

// CreateArticle Создаём статью
func (q *Queries) CreateArticle(ctx context.Context, arg CreateArticleParams) (Article, error) {
	row := q.db.QueryRow(ctx, createArticle, arg.Title, arg.Text, arg.Authors)
	var i Article
	err := row.Scan(
		&i.IDArticle,
		&i.CreatedAt,
		&i.EditedAt,
		&i.Title,
		&i.Text,
		&i.Comments,
		&i.Authors,
		&i.Evaluation,
	)
	return i, err
}

const deleteArticle = `-- name: DeleteArticle :one
WITH deleted_comments AS ( -- Объединяем 2 запроса в 1
    DELETE FROM comments
    WHERE id_comment = ANY ((SELECT comments FROM articles
                            WHERE id_article = $1::integer)::text::integer[])
)
DELETE FROM articles
WHERE id_article = $1::integer
RETURNING id_article, created_at, edited_at, title, text, comments, authors, evaluation
`

// DeleteArticle Удаляем статью и комментарии к ней
func (q *Queries) DeleteArticle(ctx context.Context, idArticle int32) (Article, error) {
	row := q.db.QueryRow(ctx, deleteArticle, idArticle)
	var i Article
	err := row.Scan(
		&i.IDArticle,
		&i.CreatedAt,
		&i.EditedAt,
		&i.Title,
		&i.Text,
		&i.Comments,
		&i.Authors,
		&i.Evaluation,
	)
	return i, err
}

const editArticleParam = `-- name: EditArticleParam :one
UPDATE articles
SET
  edited_at = COALESCE($1::timestamp , edited_at),
  -- Крч если через go передать в качестве текстового аргумента nil то он замениться на '',
  -- а '' != NULL поэтому она вставиться как пустая строка, хотя в go мы передали nil
  -- (Кстати, "::text" <- эти штуки нужны чтобы вместа pgtype был string/int32)
  title = CASE WHEN $2::text <> '' THEN $2::text ELSE title END,
  text = CASE WHEN $3::text <> '' THEN $3::text ELSE text END,
  comments = COALESCE($4, comments),
  authors = COALESCE($5, authors),
  evaluation = COALESCE($6, evaluation)
WHERE id_article = $7
RETURNING id_article, created_at, edited_at, title, text, comments, authors, evaluation
`

type EditArticleParamParams struct {
	EditedAt   pgtype.Timestamp `json:"edited_at"`
	Title      string           `json:"title"`
	Text       string           `json:"text"`
	Comments   []int32          `json:"comments"`
	Authors    []int32          `json:"authors"`
	Evaluation int32            `json:"evaluation"`
	IDArticle  int32            `json:"id_article"`
}

// EditArticleParam Изменяем параметр(ы) статьи
func (q *Queries) EditArticleParam(ctx context.Context, arg EditArticleParamParams) (Article, error) {
	row := q.db.QueryRow(ctx, editArticleParam,
		arg.EditedAt,
		arg.Title,
		arg.Text,
		arg.Comments,
		arg.Authors,
		arg.Evaluation,
		arg.IDArticle,
	)
	var i Article
	err := row.Scan(
		&i.IDArticle,
		&i.CreatedAt,
		&i.EditedAt,
		&i.Title,
		&i.Text,
		&i.Comments,
		&i.Authors,
		&i.Evaluation,
	)
	return i, err
}

const getArticle = `-- name: GetArticle :one
SELECT id_article, created_at, edited_at, title, text, comments, authors, evaluation FROM articles
WHERE id_article = $1
`

// GetArticle Возвращаем статью по id
func (q *Queries) GetArticle(ctx context.Context, idArticle int32) (Article, error) {
	row := q.db.QueryRow(ctx, getArticle, idArticle)
	var i Article
	err := row.Scan(
		&i.IDArticle,
		&i.CreatedAt,
		&i.EditedAt,
		&i.Title,
		&i.Text,
		&i.Comments,
		&i.Authors,
		&i.Evaluation,
	)
	return i, err
}

const getArticlesWithAttribute = `-- name: GetArticlesWithAttribute :many
SELECT id_article, created_at, edited_at, title, text, comments, authors, evaluation FROM articles
WHERE
    (NULLIF(edited_at, COALESCE($1::timestamp , edited_at)) IS NULL) AND

    -- Крч если через go передать в качестве текстового аргумента nil то он замениться на '',
    -- а '' != NULL поэтому она вставиться как пустая строка, хотя в go мы передали nil
    (title = (CASE WHEN ($2::text <> '' AND $2 <> NULL)
        THEN $2::text
        ELSE title END)) AND
    (text = (CASE WHEN ($3::text <> '' AND $2 <> NULL)
        THEN $3::text
        ELSE text END)) AND

    (NULLIF(comments, COALESCE($4, comments)) IS NULL) AND
    (NULLIF(authors, COALESCE($5, authors)) IS NULL) AND
    (NULLIF(evaluation, COALESCE($6, evaluation)) IS NULL)
LIMIT $8::integer
OFFSET $7::integer
`

type GetArticlesWithAttributeParams struct {
	EditedAt   pgtype.Timestamp `json:"edited_at"`
	Title      string           `json:"title"`
	Text       string           `json:"text"`
	Comments   []int32          `json:"comments"`
	Authors    []int32          `json:"authors"`
	Evaluation int32            `json:"evaluation"`
	Offset     int32            `json:"Offset"`
	Limit      int32            `json:"Limit"`
}

// GetArticlesWithAttribute Возвращаем много статей взятых по какому-то признаку(ам)
func (q *Queries) GetArticlesWithAttribute(ctx context.Context, arg GetArticlesWithAttributeParams) ([]Article, error) {
	rows, err := q.db.Query(ctx, getArticlesWithAttribute,
		arg.EditedAt,
		arg.Title,
		arg.Text,
		arg.Comments,
		arg.Authors,
		arg.Evaluation,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Article{}
	for rows.Next() {
		var i Article
		if err := rows.Scan(
			&i.IDArticle,
			&i.CreatedAt,
			&i.EditedAt,
			&i.Title,
			&i.Text,
			&i.Comments,
			&i.Authors,
			&i.Evaluation,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getManySortedArticles = `-- name: GetManySortedArticles :many
SELECT id_article, created_at, edited_at, title, text, comments, authors, evaluation FROM articles
ORDER BY $1::text
LIMIT $3::integer
OFFSET $2::integer
`

type GetManySortedArticlesParams struct {
	SortedAt string `json:"sorted_at"`
	Offset   int32  `json:"Offset"`
	Limit    int32  `json:"Limit"`
}

// GetManySortedArticles Возвращаем много статей отсортированных по признаку sorted_at
func (q *Queries) GetManySortedArticles(ctx context.Context, arg GetManySortedArticlesParams) ([]Article, error) {
	rows, err := q.db.Query(ctx, getManySortedArticles, arg.SortedAt, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Article{}
	for rows.Next() {
		var i Article
		if err := rows.Scan(
			&i.IDArticle,
			&i.CreatedAt,
			&i.EditedAt,
			&i.Title,
			&i.Text,
			&i.Comments,
			&i.Authors,
			&i.Evaluation,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getManySortedArticlesWithAttribute = `-- name: GetManySortedArticlesWithAttribute :many
SELECT id_article, created_at, edited_at, title, text, comments, authors, evaluation FROM articles
WHERE
    edited_at = COALESCE($1::timestamp , edited_at) AND

    -- Крч если через go передать в качестве текстового аргумента nil то он замениться на '',
    -- а '' != NULL поэтому она вставиться как пустая строка, хотя в go мы передали nil
    title = CASE WHEN $2::text <> '' THEN $2::text ELSE title END AND
    text = CASE WHEN $3::text <> '' THEN $3::text ELSE text END     AND

    comments = COALESCE($4, comments)                AND
    authors = COALESCE($5, authors)                   AND
    evaluation = COALESCE($6, evaluation)
ORDER BY $7::text
LIMIT $9::integer
OFFSET $8::integer
`

type GetManySortedArticlesWithAttributeParams struct {
	EditedAt   pgtype.Timestamp `json:"edited_at"`
	Title      string           `json:"title"`
	Text       string           `json:"text"`
	Comments   []int32          `json:"comments"`
	Authors    []int32          `json:"authors"`
	Evaluation int32            `json:"evaluation"`
	SortedAt   string           `json:"sorted_at"`
	Offset     int32            `json:"Offset"`
	Limit      int32            `json:"Limit"`
}

// GetManySortedArticlesWithAttribute Возвращаем много статей взятых по признаку по
// какому-то признаку(ам) отсортированных по признаку sortedAt
func (q *Queries) GetManySortedArticlesWithAttribute(ctx context.Context, arg GetManySortedArticlesWithAttributeParams) ([]Article, error) {
	rows, err := q.db.Query(ctx, getManySortedArticlesWithAttribute,
		arg.EditedAt,
		arg.Title,
		arg.Text,
		arg.Comments,
		arg.Authors,
		arg.Evaluation,
		arg.SortedAt,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Article{}
	for rows.Next() {
		var i Article
		if err := rows.Scan(
			&i.IDArticle,
			&i.CreatedAt,
			&i.EditedAt,
			&i.Title,
			&i.Text,
			&i.Comments,
			&i.Authors,
			&i.Evaluation,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
