// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: article.sql

package db

import (
	"context"
)

const addArticleAuthors = `-- name: AddArticleAuthors :exec
UPDATE articles
SET authors = array_append(authors, $2)
WHERE id_article = $1
`

type AddArticleAuthorsParams struct {
	IDArticle   int32
	ArrayAppend int32
}

// AddArticleAuthors Добавляем автора статьи
func (q *Queries) AddArticleAuthors(ctx context.Context, arg AddArticleAuthorsParams) error {
	_, err := q.db.Exec(ctx, addArticleAuthors, arg.IDArticle, arg.ArrayAppend)
	return err
}

const createArticle = `-- name: CreateArticle :exec
INSERT INTO articles (title, text, authors)
VALUES ($1, $2, $3)
`

type CreateArticleParams struct {
	Title   string
	Text    string
	Authors []int32
}

// CreateArticle Создаём статью
func (q *Queries) CreateArticle(ctx context.Context, arg CreateArticleParams) error {
	_, err := q.db.Exec(ctx, createArticle, arg.Title, arg.Text, arg.Authors)
	return err
}

const deleteArticleAuthors = `-- name: DeleteArticleAuthors :exec
UPDATE articles
SET authors = array_remove(authors, $2)
WHERE id_article = $1
`

type DeleteArticleAuthorsParams struct {
	IDArticle   int32
	ArrayRemove int32
}

// DeleteArticleAuthors Удаляем автора статьи
func (q *Queries) DeleteArticleAuthors(ctx context.Context, arg DeleteArticleAuthorsParams) error {
	_, err := q.db.Exec(ctx, deleteArticleAuthors, arg.IDArticle, arg.ArrayRemove)
	return err
}

const editArticleText = `-- name: EditArticleText :exec
WITH update_time AS (
    UPDATE articles
    SET edited_at = now()
    WHERE id_article = $1::integer
)
UPDATE articles
SET text = $2::text
WHERE id_article = $1::integer
`

type EditArticleTextParams struct {
	Column1 int32
	Column2 string
}

// EditArticleText Изменяем текст статьи и обновляем время изменения статьи (Column1 = id_article, Column2 = text)
func (q *Queries) EditArticleText(ctx context.Context, arg EditArticleTextParams) error {
	_, err := q.db.Exec(ctx, editArticleText, arg.Column1, arg.Column2)
	return err
}

const editArticleTitle = `-- name: EditArticleTitle :exec
UPDATE articles
SET title = $2
WHERE id_article = $1
`

type EditArticleTitleParams struct {
	IDArticle int32
	Title     string
}

// EditArticleTitle Изменяем заголовок статьи
func (q *Queries) EditArticleTitle(ctx context.Context, arg EditArticleTitleParams) error {
	_, err := q.db.Exec(ctx, editArticleTitle, arg.IDArticle, arg.Title)
	return err
}

const getArticle = `-- name: GetArticle :one
SELECT id_article, created_at, edited_at, title, text, comments, authors, evaluation FROM articles
WHERE id_article = $1
`

// GetArticle Возвращаем статью по id
func (q *Queries) GetArticle(ctx context.Context, idArticle int32) (Article, error) {
	row := q.db.QueryRow(ctx, getArticle, idArticle)
	var i Article
	err := row.Scan(
		&i.IDArticle,
		&i.CreatedAt,
		&i.EditedAt,
		&i.Title,
		&i.Text,
		&i.Comments,
		&i.Authors,
		&i.Evaluation,
	)
	return i, err
}

const getArticlesWithEvalution = `-- name: GetArticlesWithEvalution :many
SELECT id_article, created_at, edited_at, title, text, comments, authors, evaluation FROM articles
WHERE evaluation = $1
LIMIT $2
OFFSET $3
`

type GetArticlesWithEvalutionParams struct {
	Evaluation int32
	Limit      int64
	Offset     int64
}

// GetArticlesWithEvalution Возвращаем много статей взятых по оценке
func (q *Queries) GetArticlesWithEvalution(ctx context.Context, arg GetArticlesWithEvalutionParams) ([]Article, error) {
	rows, err := q.db.Query(ctx, getArticlesWithEvalution, arg.Evaluation, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Article
	for rows.Next() {
		var i Article
		if err := rows.Scan(
			&i.IDArticle,
			&i.CreatedAt,
			&i.EditedAt,
			&i.Title,
			&i.Text,
			&i.Comments,
			&i.Authors,
			&i.Evaluation,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getArticlesWithTitle = `-- name: GetArticlesWithTitle :many
SELECT id_article, created_at, edited_at, title, text, comments, authors, evaluation FROM articles
WHERE title = $1
LIMIT $2
OFFSET $3
`

type GetArticlesWithTitleParams struct {
	Title  string
	Limit  int64
	Offset int64
}

// GetArticlesWithTitle Возвращаем много статей взятых по названию
func (q *Queries) GetArticlesWithTitle(ctx context.Context, arg GetArticlesWithTitleParams) ([]Article, error) {
	rows, err := q.db.Query(ctx, getArticlesWithTitle, arg.Title, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Article
	for rows.Next() {
		var i Article
		if err := rows.Scan(
			&i.IDArticle,
			&i.CreatedAt,
			&i.EditedAt,
			&i.Title,
			&i.Text,
			&i.Comments,
			&i.Authors,
			&i.Evaluation,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getManySortedArticles = `-- name: GetManySortedArticles :many
SELECT id_article, created_at, edited_at, title, text, comments, authors, evaluation FROM articles
ORDER BY $1::text
LIMIT $2
OFFSET $3
`

type GetManySortedArticlesParams struct {
	Column1 string
	Limit   int64
	Offset  int64
}

// GetManySortedArticles Возвращаем много статей отсортированных по признаку Column1
func (q *Queries) GetManySortedArticles(ctx context.Context, arg GetManySortedArticlesParams) ([]Article, error) {
	rows, err := q.db.Query(ctx, getManySortedArticles, arg.Column1, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Article
	for rows.Next() {
		var i Article
		if err := rows.Scan(
			&i.IDArticle,
			&i.CreatedAt,
			&i.EditedAt,
			&i.Title,
			&i.Text,
			&i.Comments,
			&i.Authors,
			&i.Evaluation,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
