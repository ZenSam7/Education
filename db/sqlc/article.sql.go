// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: article.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createArticle = `-- name: CreateArticle :one
INSERT INTO articles (title, text, authors)
VALUES ($1, $2, $3)
RETURNING id_article, created_at, edited_at, title, text, comments, authors, evaluation
`

type CreateArticleParams struct {
	Title   string  `json:"title"`
	Text    string  `json:"text"`
	Authors []int32 `json:"authors"`
}

// CreateArticle Создаём статью
func (q *Queries) CreateArticle(ctx context.Context, arg CreateArticleParams) (Article, error) {
	row := q.db.QueryRow(ctx, createArticle, arg.Title, arg.Text, arg.Authors)
	var i Article
	err := row.Scan(
		&i.IDArticle,
		&i.CreatedAt,
		&i.EditedAt,
		&i.Title,
		&i.Text,
		&i.Comments,
		&i.Authors,
		&i.Evaluation,
	)
	return i, err
}

const deleteArticle = `-- name: DeleteArticle :one
WITH deleted_comments AS ( -- Объединяем 2 запроса в 1
    DELETE FROM comments
    WHERE id_comment = ANY ((SELECT comments FROM articles
                            WHERE id_article = $1::integer)::text::integer[])
)
DELETE FROM articles
WHERE id_article = $1::integer
RETURNING id_article, created_at, edited_at, title, text, comments, authors, evaluation
`

// DeleteArticle Удаляем статью и комментарии к ней
func (q *Queries) DeleteArticle(ctx context.Context, idArticle int32) (Article, error) {
	row := q.db.QueryRow(ctx, deleteArticle, idArticle)
	var i Article
	err := row.Scan(
		&i.IDArticle,
		&i.CreatedAt,
		&i.EditedAt,
		&i.Title,
		&i.Text,
		&i.Comments,
		&i.Authors,
		&i.Evaluation,
	)
	return i, err
}

const editArticleParam = `-- name: EditArticleParam :one
UPDATE articles
SET
  edited_at = COALESCE($1::timestamp , edited_at),
  -- Крч если через go передать в качестве текстового аргумента nil то он замениться на '',
  -- а '' != NULL поэтому она вставиться как пустая строка, хотя в go мы передали nil
  -- (Кстати, "::text" <- эти штуки нужны чтобы вместа pgtype был string/int32)
  title = CASE WHEN $2::text <> '' THEN $2::text ELSE title END,
  text = CASE WHEN $3::text <> '' THEN $3::text ELSE text END,
  comments = COALESCE($4, comments),
  authors = COALESCE($5, authors),
  evaluation = COALESCE($6, evaluation)
WHERE id_article = $7
RETURNING id_article, created_at, edited_at, title, text, comments, authors, evaluation
`

type EditArticleParamParams struct {
	EditedAt   pgtype.Timestamp `json:"edited_at"`
	Title      string           `json:"title"`
	Text       string           `json:"text"`
	Comments   []int32          `json:"comments"`
	Authors    []int32          `json:"authors"`
	Evaluation int32            `json:"evaluation"`
	IDArticle  int32            `json:"id_article"`
}

// EditArticleParam Изменяем параметр(ы) статьи
func (q *Queries) EditArticleParam(ctx context.Context, arg EditArticleParamParams) (Article, error) {
	row := q.db.QueryRow(ctx, editArticleParam,
		arg.EditedAt,
		arg.Title,
		arg.Text,
		arg.Comments,
		arg.Authors,
		arg.Evaluation,
		arg.IDArticle,
	)
	var i Article
	err := row.Scan(
		&i.IDArticle,
		&i.CreatedAt,
		&i.EditedAt,
		&i.Title,
		&i.Text,
		&i.Comments,
		&i.Authors,
		&i.Evaluation,
	)
	return i, err
}

const getArticle = `-- name: GetArticle :one
SELECT id_article, created_at, edited_at, title, text, comments, authors, evaluation FROM articles
WHERE id_article = $1
`

// GetArticle Возвращаем статью по id
func (q *Queries) GetArticle(ctx context.Context, idArticle int32) (Article, error) {
	row := q.db.QueryRow(ctx, getArticle, idArticle)
	var i Article
	err := row.Scan(
		&i.IDArticle,
		&i.CreatedAt,
		&i.EditedAt,
		&i.Title,
		&i.Text,
		&i.Comments,
		&i.Authors,
		&i.Evaluation,
	)
	return i, err
}

const getArticlesWithAttribute = `-- name: GetArticlesWithAttribute :many
SELECT id_article, created_at, edited_at, title, text, comments, authors, evaluation FROM articles
WHERE
    (NULLIF(edited_at, COALESCE($1::timestamp , edited_at)) IS NULL) AND

    -- Крч если через go передать в качестве текстового аргумента nil то он замениться на '',
    -- а '' != NULL поэтому она вставиться как пустая строка, хотя в go мы передали nil
    (title = (CASE WHEN ($2::text <> '' AND $2 <> NULL)
        THEN $2::text
        ELSE title END)) AND
    (text = (CASE WHEN ($3::text <> '' AND $2 <> NULL)
        THEN $3::text
        ELSE text END)) AND

    (NULLIF(comments, COALESCE($4, comments)) IS NULL) AND
    (NULLIF(authors, COALESCE($5, authors)) IS NULL) AND
    (NULLIF(evaluation, COALESCE($6, evaluation)) IS NULL)
LIMIT $8::integer
OFFSET $7::integer
`

type GetArticlesWithAttributeParams struct {
	EditedAt   pgtype.Timestamp `json:"edited_at"`
	Title      string           `json:"title"`
	Text       string           `json:"text"`
	Comments   []int32          `json:"comments"`
	Authors    []int32          `json:"authors"`
	Evaluation int32            `json:"evaluation"`
	Offset     int32            `json:"Offset"`
	Limit      int32            `json:"Limit"`
}

// GetArticlesWithAttribute Возвращаем много статей взятых по какому-то признаку(ам)
func (q *Queries) GetArticlesWithAttribute(ctx context.Context, arg GetArticlesWithAttributeParams) ([]Article, error) {
	rows, err := q.db.Query(ctx, getArticlesWithAttribute,
		arg.EditedAt,
		arg.Title,
		arg.Text,
		arg.Comments,
		arg.Authors,
		arg.Evaluation,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Article{}
	for rows.Next() {
		var i Article
		if err := rows.Scan(
			&i.IDArticle,
			&i.CreatedAt,
			&i.EditedAt,
			&i.Title,
			&i.Text,
			&i.Comments,
			&i.Authors,
			&i.Evaluation,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getManySortedArticles = `-- name: GetManySortedArticles :many
SELECT id_article, created_at, edited_at, title, text, comments, authors, evaluation FROM articles
ORDER BY
        CASE WHEN $1::boolean THEN id_article::integer
             WHEN $2::boolean THEN evaluation::integer END
        , -- запятая
        CASE WHEN $3::boolean THEN comments::integer[]
             WHEN $4::boolean THEN authors::integer[] END
        , -- запятая
        CASE WHEN $5::boolean THEN title::text
             WHEN $6::boolean THEN text::text END
        , -- запятая
        CASE WHEN $7::boolean THEN edited_at::timestamp
             WHEN $8::boolean THEN created_at::timestamp END
LIMIT $10::integer
OFFSET $9::integer
`

type GetManySortedArticlesParams struct {
	IDArticle  bool  `json:"id_article"`
	Evaluation bool  `json:"evaluation"`
	Comments   bool  `json:"comments"`
	Authors    bool  `json:"authors"`
	Title      bool  `json:"title"`
	Text       bool  `json:"text"`
	EditedAt   bool  `json:"edited_at"`
	CreatedAt  bool  `json:"created_at"`
	Offset     int32 `json:"Offset"`
	Limit      int32 `json:"Limit"`
}

// GetManySortedArticles Возвращаем много отсортированных статей
func (q *Queries) GetManySortedArticles(ctx context.Context, arg GetManySortedArticlesParams) ([]Article, error) {
	rows, err := q.db.Query(ctx, getManySortedArticles,
		arg.IDArticle,
		arg.Evaluation,
		arg.Comments,
		arg.Authors,
		arg.Title,
		arg.Text,
		arg.EditedAt,
		arg.CreatedAt,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Article{}
	for rows.Next() {
		var i Article
		if err := rows.Scan(
			&i.IDArticle,
			&i.CreatedAt,
			&i.EditedAt,
			&i.Title,
			&i.Text,
			&i.Comments,
			&i.Authors,
			&i.Evaluation,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getManySortedArticlesWithAttribute = `-- name: GetManySortedArticlesWithAttribute :many
SELECT id_article, created_at, edited_at, title, text, comments, authors, evaluation FROM articles
WHERE
    edited_at = COALESCE($1::timestamp , edited_at) AND

    -- Крч если через go передать в качестве текстового аргумента nil то он замениться на '',
    -- а '' != NULL поэтому она вставиться как пустая строка, хотя в go мы передали nil
    title = CASE WHEN $2::text <> '' THEN $2::text ELSE title END AND
    text = CASE WHEN $3::text <> '' THEN $3::text ELSE text END     AND

    comments = COALESCE($4, comments)                AND
    authors = COALESCE($5, authors)                   AND
    evaluation = COALESCE($6, evaluation)

ORDER BY
        CASE WHEN $7::boolean THEN id_article::integer
             WHEN $8::boolean THEN evaluation::integer END
        , -- запятая
        CASE WHEN $9::boolean THEN comments::integer[]
             WHEN $10::boolean THEN authors::integer[] END
        , -- запятая
        CASE WHEN $11::boolean THEN title::text
             WHEN $12::boolean THEN text::text END
        , -- запятая
        CASE WHEN $13::boolean THEN edited_at::timestamp
             WHEN $14::boolean THEN created_at::timestamp END

LIMIT $16::integer
OFFSET $15::integer
`

type GetManySortedArticlesWithAttributeParams struct {
	SelectByEditedAt   pgtype.Timestamp `json:"select_by_edited_at"`
	SelectByTitle      string           `json:"select_by_title"`
	SelectByText       string           `json:"select_by_text"`
	SelectByComments   []int32          `json:"select_by_comments"`
	SelectByAuthors    []int32          `json:"select_by_authors"`
	SelectByEvaluation int32            `json:"select_by_evaluation"`
	SortedByIDArticle  bool             `json:"sorted_by_id_article"`
	SortedByEvaluation bool             `json:"sorted_by_evaluation"`
	SortedByComments   bool             `json:"sorted_by_comments"`
	SortedByAuthors    bool             `json:"sorted_by_authors"`
	SortedByTitle      bool             `json:"sorted_by_title"`
	SortedByText       bool             `json:"sorted_by_text"`
	SortedByEditedAt   bool             `json:"sorted_by_edited_at"`
	SortedByCreatedAt  bool             `json:"sorted_by_created_at"`
	Offset             int32            `json:"Offset"`
	Limit              int32            `json:"Limit"`
}

// GetManySortedArticlesWithAttribute Возвращаем много статей взятых по признаку по
// какому-то признаку(ам) отсортированных по признаку
func (q *Queries) GetManySortedArticlesWithAttribute(ctx context.Context, arg GetManySortedArticlesWithAttributeParams) ([]Article, error) {
	rows, err := q.db.Query(ctx, getManySortedArticlesWithAttribute,
		arg.SelectByEditedAt,
		arg.SelectByTitle,
		arg.SelectByText,
		arg.SelectByComments,
		arg.SelectByAuthors,
		arg.SelectByEvaluation,
		arg.SortedByIDArticle,
		arg.SortedByEvaluation,
		arg.SortedByComments,
		arg.SortedByAuthors,
		arg.SortedByTitle,
		arg.SortedByText,
		arg.SortedByEditedAt,
		arg.SortedByCreatedAt,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Article{}
	for rows.Next() {
		var i Article
		if err := rows.Scan(
			&i.IDArticle,
			&i.CreatedAt,
			&i.EditedAt,
			&i.Title,
			&i.Text,
			&i.Comments,
			&i.Authors,
			&i.Evaluation,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
