// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: article.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createArticle = `-- name: CreateArticle :exec
INSERT INTO articles (title, text, authors)
VALUES ($1, $2, $3)
RETURNING id_article, created_at, edited_at, title, text, comments, authors, evaluation
`

type CreateArticleParams struct {
	Title   string
	Text    string
	Authors []int32
}

// CreateArticle Создаём статью
func (q *Queries) CreateArticle(ctx context.Context, arg CreateArticleParams) error {
	_, err := q.db.Exec(ctx, createArticle, arg.Title, arg.Text, arg.Authors)
	return err
}

const editArticleParam = `-- name: EditArticleParam :one
UPDATE articles
SET
  edited_at = COALESCE($1::timestamp , edited_at),
  title = COALESCE($2::text, title),
  text = COALESCE($3, text),
  comments = COALESCE($4, comments),
  authors = COALESCE($5, authors),
  evaluation = COALESCE($6, evaluation)
WHERE id_article = $7
RETURNING id_article, created_at, edited_at, title, text, comments, authors, evaluation
`

type EditArticleParamParams struct {
	EditedAt   pgtype.Timestamp
	Title      string
	Text       string
	Comments   []int32
	Authors    []int32
	Evaluation int32
	IDArticle  int32
}

// EditArticleParam Изменяем параметр(ы) статьи
func (q *Queries) EditArticleParam(ctx context.Context, arg EditArticleParamParams) (Article, error) {
	row := q.db.QueryRow(ctx, editArticleParam,
		arg.EditedAt,
		arg.Title,
		arg.Text,
		arg.Comments,
		arg.Authors,
		arg.Evaluation,
		arg.IDArticle,
	)
	var i Article
	err := row.Scan(
		&i.IDArticle,
		&i.CreatedAt,
		&i.EditedAt,
		&i.Title,
		&i.Text,
		&i.Comments,
		&i.Authors,
		&i.Evaluation,
	)
	return i, err
}

const getArticle = `-- name: GetArticle :one
SELECT id_article, created_at, edited_at, title, text, comments, authors, evaluation FROM articles
WHERE id_article = $1
`

// GetArticle Возвращаем статью по id
func (q *Queries) GetArticle(ctx context.Context, idArticle int32) (Article, error) {
	row := q.db.QueryRow(ctx, getArticle, idArticle)
	var i Article
	err := row.Scan(
		&i.IDArticle,
		&i.CreatedAt,
		&i.EditedAt,
		&i.Title,
		&i.Text,
		&i.Comments,
		&i.Authors,
		&i.Evaluation,
	)
	return i, err
}

const getArticlesWithAttribute = `-- name: GetArticlesWithAttribute :many
SELECT id_article, created_at, edited_at, title, text, comments, authors, evaluation FROM articles
WHERE $3::text = $4::text
LIMIT $1
OFFSET $2
`

type GetArticlesWithAttributeParams struct {
	Limit          int64
	Offset         int64
	Attribute      string
	AttributeValue string
}

// GetArticlesWithAttribute Возвращаем много статей взятых по признаку attribute
func (q *Queries) GetArticlesWithAttribute(ctx context.Context, arg GetArticlesWithAttributeParams) ([]Article, error) {
	rows, err := q.db.Query(ctx, getArticlesWithAttribute,
		arg.Limit,
		arg.Offset,
		arg.Attribute,
		arg.AttributeValue,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Article
	for rows.Next() {
		var i Article
		if err := rows.Scan(
			&i.IDArticle,
			&i.CreatedAt,
			&i.EditedAt,
			&i.Title,
			&i.Text,
			&i.Comments,
			&i.Authors,
			&i.Evaluation,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getManySortedArticles = `-- name: GetManySortedArticles :many
SELECT id_article, created_at, edited_at, title, text, comments, authors, evaluation FROM articles
ORDER BY $3::text
LIMIT $1
OFFSET $2
`

type GetManySortedArticlesParams struct {
	Limit    int64
	Offset   int64
	SortedAt string
}

// GetManySortedArticles Возвращаем много статей отсортированных по признаку attribute
func (q *Queries) GetManySortedArticles(ctx context.Context, arg GetManySortedArticlesParams) ([]Article, error) {
	rows, err := q.db.Query(ctx, getManySortedArticles, arg.Limit, arg.Offset, arg.SortedAt)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Article
	for rows.Next() {
		var i Article
		if err := rows.Scan(
			&i.IDArticle,
			&i.CreatedAt,
			&i.EditedAt,
			&i.Title,
			&i.Text,
			&i.Comments,
			&i.Authors,
			&i.Evaluation,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getManySortedArticlesWithAttribute = `-- name: GetManySortedArticlesWithAttribute :many
SELECT id_article, created_at, edited_at, title, text, comments, authors, evaluation FROM articles
WHERE $3::text = $4::text
ORDER BY $5::text
LIMIT $1
OFFSET $2
`

type GetManySortedArticlesWithAttributeParams struct {
	Limit          int64
	Offset         int64
	Attribute      string
	AttributeValue string
	SortedAt       string
}

// GetManySortedArticlesWithAttribute Возвращаем много статей взятых по признаку attridute отсортированных по признаку sortedAt
func (q *Queries) GetManySortedArticlesWithAttribute(ctx context.Context, arg GetManySortedArticlesWithAttributeParams) ([]Article, error) {
	rows, err := q.db.Query(ctx, getManySortedArticlesWithAttribute,
		arg.Limit,
		arg.Offset,
		arg.Attribute,
		arg.AttributeValue,
		arg.SortedAt,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Article
	for rows.Next() {
		var i Article
		if err := rows.Scan(
			&i.IDArticle,
			&i.CreatedAt,
			&i.EditedAt,
			&i.Title,
			&i.Text,
			&i.Comments,
			&i.Authors,
			&i.Evaluation,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
